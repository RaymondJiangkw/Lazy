// text convert Chapters to .txt file
package write

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/bmaupin/go-epub"

	"github.com/RaymondJiangkw/Lazy/lazyNovelDownloader/extract"
)

const (
	Prologue = `	These texts are generated by lazyNovelDownloader, which is developed by RaymondJiangkw.
	This software does not provide any text by itself. Rights of texts are all reserved for original authors, who have the rights to require users to delete their works.
	Any conflict, dispute and lawsuit resulted from texts are all attributed to users. RaymondJiangkw does not take any responsibility of it.
  
	Copyright Â© 2020 RaymondJiangkw. All rights reserved.`
	Lack     = `Lack Available Content!`
	cssFile  = "epub.css"
	fontFile = "Kaiti.ttf"
)

type NovelInfo struct {
	Name   string
	Author string
}

func WriteToTxt(chapters extract.Chapters, filePath string, novelInfo NovelInfo) (e error) {
	var signal chan struct{} = make(chan struct{})
	var info chan int = make(chan int)
	if !strings.HasSuffix(filePath, ".txt") {
		filePath += ".txt"
	}
	if _, err := os.Stat(filePath); !os.IsNotExist(err) {
		os.Remove(filePath)
	}
	file, e := os.Create(filePath)
	defer file.Close()
	if e != nil {
		return
	}
	fmt.Printf("Writing to file %s...\n", filepath.Base(filePath))
	novel := Prologue + "\n"
	if novelInfo.Name != "" {
		novel += "Name:	" + novelInfo.Name + "\n"
	}
	if novelInfo.Author != "" {
		novel += "Author:	" + novelInfo.Author + "\n"
	}
	go extract.ProgressBar("	", "", len(chapters), extract.ProgressBarWidth, time.Second, signal, info)
	for finish, c := range chapters {
		novel += "\n" + c.Name + "\n"
		if !c.Fetch {
			novel += Lack
		} else {
			novel += c.Content
		}
		novel += "\n"
		info <- (finish + 1)
	}
	signal <- struct{}{}
	_, e = file.WriteString(novel)
	return
}

func WriteToEpub(chapters extract.Chapters, filePath string, novelInfo NovelInfo) (e error) {
	var signal chan struct{} = make(chan struct{})
	var info chan int = make(chan int)
	if !strings.HasSuffix(filePath, ".epub") {
		filePath += ".epub"
	}
	if _, err := os.Stat(filePath); !os.IsNotExist(err) {
		os.Remove(filePath)
	}
	if e != nil {
		return
	}
	fmt.Printf("Writing to file %s...\n", filepath.Base(filePath))
	var novelName string
	novelName = novelInfo.Name
	epub := epub.NewEpub(novelName)
	// Set Novel Information
	epub.SetAuthor(novelInfo.Author)
	epub.SetDescription(Prologue)
	// Set CSS and Font
	cssPath, _ := filepath.Abs(cssFile)
	fontPath, _ := filepath.Abs(fontFile)
	epub.AddFont(fontPath, fontFile)
	epub.AddCSS(cssPath, cssFile)
	epub.AddSection(`<p>`+EpubFormatString(Prologue)+`</p>`, "Prologue", "prologue.xhtml", "")
	// Generate Catalog
	catalog := `<h1>` + `Catalog` + `</h1>`
	catalog += `<div id="catalog">`
	for finish, c := range chapters {
		catalog += `<a href="` + strconv.Itoa(finish) + `.xhtml">` + c.Name + `</a><br />`
	}
	catalog += `</div>`
	epub.AddSection(catalog, "Catalog", "catalog.xhtml", "")
	go extract.ProgressBar("	", "", len(chapters), extract.ProgressBarWidth, time.Second, signal, info)
	for finish, c := range chapters {
		content := c.Content
		if !c.Fetch {
			content = Lack
		}
		_, e = epub.AddSection(`<h2>`+c.Name+`</h2>`+`<div id="content">`+EpubFormatString(content)+`</div>`+`<div id="foot">`+`<a href="catalog.xhtml" align="right">Back to Catalog</a>`+`</div>`, c.Name, strconv.Itoa(finish)+".xhtml", "")
		if e != nil {
			// Recycle ProgressBar
			signal <- struct{}{}
			return
		}
		info <- (finish + 1)
	}
	// Recycle ProgressBar
	signal <- struct{}{}
	e = epub.Write(filePath)
	return
}

func EpubFormatString(s string) (ret string) {
	r := bufio.NewScanner(strings.NewReader(s))
	for r.Scan() {
		ret += `<p>` + r.Text() + `</p>`
	}
	return
}
